//this file was not autogenerated

#include "nnetwork.h"
#include <stdio.h>
//#define PRINT_DEBUG

static struct NeuralNetwork netw;

float run_XOR_ANN(float x1, float x2) {
    float inputs[2] = {x1, x2};
    RunNetwork(inputs);
    return ThresholdFunction(netw.Neurons[NUM_NEURONS-1].InputValue);
}

void __attribute__((noinline)) run_XOR_ANN_l1(float x1, float x2) {
	float inputs[2] = {x1, x2};
    RunNetwork_l1(inputs);
}

void __attribute__((noinline)) run_XOR_ANN_l2() {
	RunNetwork_l2();
}

float __attribute__((noinline)) run_XOR_ANN_l3() {
	RunNetwork_l3();
	return ThresholdFunction(netw.Neurons[NUM_NEURONS-1].InputValue);
}

float ThresholdFunction(float input) {
	return (float)(input >= 1);
}

//RunNetwork will run the network and feed-forward all values
void RunNetwork(float inputs[LAYERS_INPUT_LEN]) {
	//assign the values to the input neurons
	for(uint32_t i=0; i < LAYERS_INPUT_LEN; i++) {
		netw.Neurons[i].InputValue = inputs[i];
		#ifdef PRINT_DEBUG 
		printf("Neuron %d assigned value %f\n", i, inputs[i]);
		#endif
	}

	//reset the neural network (aside from the input neurons)
	for(uint32_t i=LAYERS_INPUT_LEN; i < NUM_NEURONS; i++) {
		netw.Neurons[i].InputValue = 0;
	}

	//for each of the connections, update the associated neurons
	//because we store all connections in order, there's no risk of updating a neuron after we've started consuming its output
	//(i.e., all neurons will have their final InputValue known before you need to use that to start on the next neuron)
	for(uint32_t i=0; i < NUM_CONNECTIONS; i++) {
		struct NeuralNetworkNeuron* src = &(netw.Neurons[netw.Connections[i].Source]);
		struct NeuralNetworkNeuron* dest = &(netw.Neurons[netw.Connections[i].Destination]);

		dest->InputValue += ThresholdFunction(src->InputValue) * netw.Connections[i].Weight;
		#ifdef PRINT_DEBUG
		printf("src neuron %d (with out val %f converted to %f) added to dest neuron %d (taking in value to %f)\n", 
			netw.Connections[i].Source,
			ThresholdFunction(src->InputValue),
			ThresholdFunction(src->InputValue) * netw.Connections[i].Weight,
			netw.Connections[i].Destination,
			dest->InputValue);
		#endif
	}
}

//RunNetwork will run the network and feed-forward all values
void RunNetwork_l1(float inputs[LAYERS_INPUT_LEN]) {
	//assign the values to the input neurons
	for(uint32_t i=0; i < LAYERS_INPUT_LEN; i++) {
		netw.Neurons[i].InputValue = inputs[i];
		#ifdef PRINT_DEBUG 
		printf("Neuron %d assigned value %f\n", i, inputs[i]);
		#endif
	}

	//reset the neural network (aside from the input neurons)
	for(uint32_t i=LAYERS_INPUT_LEN; i < NUM_NEURONS; i++) {
		netw.Neurons[i].InputValue = 0;
	}
}

//RunNetwork will run the network and feed-forward all values
void RunNetwork_l2() {
	//for each of the connections, update the associated neurons
	//because we store all connections in order, there's no risk of updating a neuron after we've started consuming its output
	//(i.e., all neurons will have their final InputValue known before you need to use that to start on the next neuron)
	#pragma loopbound min 0 max 6
	for(uint32_t i=0; i < 6; i++) {
		struct NeuralNetworkNeuron* src = &(netw.Neurons[netw.Connections[i].Source]);
		struct NeuralNetworkNeuron* dest = &(netw.Neurons[netw.Connections[i].Destination]);

		dest->InputValue += ThresholdFunction(src->InputValue) * netw.Connections[i].Weight;
		#ifdef PRINT_DEBUG
		printf("src neuron %d (with out val %f converted to %f) added to dest neuron %d (taking in value to %f)\n", 
			netw.Connections[i].Source,
			ThresholdFunction(src->InputValue),
			ThresholdFunction(src->InputValue) * netw.Connections[i].Weight,
			netw.Connections[i].Destination,
			dest->InputValue);
		#endif
	}
}

//RunNetwork will run the network and feed-forward all values
void RunNetwork_l3() {
	//for each of the connections, update the associated neurons
	//because we store all connections in order, there's no risk of updating a neuron after we've started consuming its output
	//(i.e., all neurons will have their final InputValue known before you need to use that to start on the next neuron)
	#pragma loopbound min 0 max 3
	for(uint32_t i=6; i < 9; i++) {
		struct NeuralNetworkNeuron* src = &(netw.Neurons[netw.Connections[i].Source]);
		struct NeuralNetworkNeuron* dest = &(netw.Neurons[netw.Connections[i].Destination]);

		dest->InputValue += ThresholdFunction(src->InputValue) * netw.Connections[i].Weight;
		#ifdef PRINT_DEBUG
		printf("src neuron %d (with out val %f converted to %f) added to dest neuron %d (taking in value to %f)\n", 
			netw.Connections[i].Source,
			ThresholdFunction(src->InputValue),
			ThresholdFunction(src->InputValue) * netw.Connections[i].Weight,
			netw.Connections[i].Destination,
			dest->InputValue);
		#endif
	}
}

//for an XOR solving MLP we have the following pre-trained setup
/*      H1
 *     /   \
 *    /(1)  \(1)
 *  I1       \
 *    \(0.5)  \
 *     \       \
 *      H2-(-2)-O1
 *     /       /
 *    /(0.5)  /
 *  I2       /
 *    \(1)  /(1)
 *     \   /
 *      H3
 * 
 */
//see https://en.wikipedia.org/wiki/Feedforward_neural_network 
//and https://en.wikipedia.org/wiki/Feedforward_neural_network#/media/File:XOR_perceptron_net.png

//InitNetwork creates a network to solve XOR
void InitNetwork() {
	
	//NUM_CONNECTIONS (LAYERS_INPUT_LEN * LAYERS_HIDDEN_LEN + (LAYERS_HIDDEN_LEN * LAYERS_HIDDEN_LEN) * (LAYERS_LEN - 2) + LAYERS_HIDDEN_LEN * LAYERS_OUTPUT_LEN)
	
	//remember that in our default config every neuron in layer N goes to every neuron in layer N+1, but in the diagram we don't illustrate lines with weight 0
	//so we're missing lines from I1 to H3, and I2 to H1 (they both have weight 0)

	//also remember that connections and neurons are both one-dimensional arrays, so to get the neuron index you have to add it to the length of all previous layers
	
	//configure all network connections
	netw.Connections[0] = (struct NeuralNetworkConnection){.Source = 0, .Destination = 2, .Weight = 1};
	netw.Connections[1] = (struct NeuralNetworkConnection){.Source = 0, .Destination = 3, .Weight = 0.5};
	netw.Connections[2] = (struct NeuralNetworkConnection){.Source = 0, .Destination = 4, .Weight = 0};

	netw.Connections[3] = (struct NeuralNetworkConnection){.Source = 1, .Destination = 2, .Weight = 0};
	netw.Connections[4] = (struct NeuralNetworkConnection){.Source = 1, .Destination = 3, .Weight = 0.5};
	netw.Connections[5] = (struct NeuralNetworkConnection){.Source = 1, .Destination = 4, .Weight = 1};

	netw.Connections[6] = (struct NeuralNetworkConnection){.Source = 2, .Destination = 5, .Weight = 1};

	netw.Connections[7] = (struct NeuralNetworkConnection){.Source = 3, .Destination = 5, .Weight = -2};

	netw.Connections[8] = (struct NeuralNetworkConnection){.Source = 4, .Destination = 5, .Weight = 1};
}